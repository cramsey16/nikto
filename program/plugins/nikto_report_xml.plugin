###############################################################################
#  Copyright (C) 2025 Chris Sullo
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; version 2
#  of the License only.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to
#  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
###############################################################################
# PURPOSE:
# XML Reporting - Multi-host support with proper XML handling
###############################################################################
our $XMLRPT_ALL = [];      # Arrayref to hold all hosts' reports
our $XMLRPT_CURR = undef;  # Scalarref to current host's report
our $XML_WRITER = undef;   # XML::Writer instance
our $XML_HANDLE = undef;   # File handle

use XML::Writer;
use Time::Piece;
use Time::Seconds;

###############################################################################
sub nikto_report_xml2_init {
    my $id = { name              => "report_xml2",
               full_name         => "XML reports (v2)",
               author            => "Sullo",
               description       => "Produces a proper XML report with validation.",
               report_head       => \&xml2_open,
               report_host_start => \&xml2_host_start,
               report_host_end   => \&xml2_host_end,
               report_close      => \&xml2_close,
               report_item       => \&xml2_item,
               report_format     => 'xml',
               copyright         => "2025 Chris Sullo"
               };
    return $id;
}

###############################################################################
# open output file
sub xml2_open {
    my ($file) = @_;
    print STDERR "+ ERROR: Output file not specified.\n" if $file eq '';

    # Open file for writing
    open(OUT, ">>$file") || die print STDERR "+ ERROR: Unable to open '$file' for write: $@\n";
    $XML_HANDLE = \*OUT;

    # Initialize XML writer with proper settings
    $XML_WRITER = XML::Writer->new(
        OUTPUT => \*OUT,
        DATA_MODE => 1,
        DATA_INDENT => 2,
        ENCODING => 'UTF-8',
        UNSAFE => 0  # Ensure proper escaping
    );

    # Write XML declaration
    $XML_WRITER->xmlDecl('UTF-8');
    
    # Write DOCTYPE if DTD is defined
    if (defined $CONFIGFILE{'NIKTODTD'} && $CONFIGFILE{'NIKTODTD'} ne '') {
        # Resolve DTD path relative to Nikto execution directory
        my $dtd_path = $CONFIGFILE{'NIKTODTD'};
        if ($dtd_path !~ /^\// && defined $CONFIGFILE{'EXECDIR'}) {
            $dtd_path = "$CONFIGFILE{'EXECDIR'}/$dtd_path";
        }
        $XML_WRITER->doctype('niktoscans', 'SYSTEM', $dtd_path);
    }
    
    # Start root element
    $XML_WRITER->startTag('niktoscans');

    nprint("- XML report initialized with proper encoding and structure", "v");
    return OUT;
}

###############################################################################
# start host entry
sub xml2_host_start {
    my ($handle, $mark) = @_;
    
    # Initialize current host report
    $XMLRPT_CURR = {
        targetip => $mark->{'ip'},
        targethostname => $mark->{'hostname'},
        targetport => $mark->{'port'},
        targetbanner => $mark->{'banner'} || '',
        starttime => date_disp($mark->{'start_time'}),
        sitename => '',
        siteip => '',
        hostheader => $mark->{'vhost'} || $mark->{'hostname'},
        errors => $mark->{'total_errors'} || 0,
        checks => $COUNTERS{'total_checks'} || 0,
        items => [],
        ssl_info => undef
    };

    # Build site URLs
    my $protocol = $mark->{'ssl'} ? 'https' : 'http';
    my $hostname = $mark->{'vhost'} || $mark->{'hostname'};
    
    $XMLRPT_CURR->{'siteip'} = "$protocol://$mark->{'ip'}:$mark->{'port'}$mark->{'root'}";
    $XMLRPT_CURR->{'siteip'} .= '/' unless $XMLRPT_CURR->{'siteip'} =~ /\/$/;
    
    if ($hostname ne '') {
        $XMLRPT_CURR->{'sitename'} = "$protocol://$hostname:$mark->{'port'}$mark->{'root'}";
        $XMLRPT_CURR->{'sitename'} .= '/' unless $XMLRPT_CURR->{'sitename'} =~ /\/$/;
    } else {
        $XMLRPT_CURR->{'sitename'} = 'N/A';
    }

    # Add SSL info if available
    if ($mark->{'ssl'} && defined $mark->{'ssl_cipher'}) {
        # Extract CN from subject for separate reporting
        my $cn = '';
        if ($mark->{'ssl_cert_subject'} =~ /CN=([^$ \/]+)/) {
            $cn = $1;
        }
        
        $XMLRPT_CURR->{'ssl_info'} = {
            ciphers => $mark->{'ssl_cipher'},
            issuers => $mark->{'ssl_cert_issuer'} || '',
            info => $mark->{'ssl_cert_subject'} || '',
            cn => $cn,
            altnames => $mark->{'ssl_cert_altnames'} || ''
        };
    }

    push(@$XMLRPT_ALL, $XMLRPT_CURR);

    # Write niktoscan start tag with all required attributes
    $XML_WRITER->startTag('niktoscan',
        hoststest => $COUNTERS{'hosts_completed'} || 0,
        options => $CLI{'all_options'} || '',
        version => $VARIABLES{'version'} || 'unknown',
        scanstart => localtime($COUNTERS{'scan_start'}) || '',
        scanend => localtime($COUNTERS{'scan_end'}) || '',
        scanelapsed => ($COUNTERS{'scan_elapsed'} || 0),
        nxmlversion => "1.2"
    );

    # Write scandetails start tag
    $XML_WRITER->startTag('scandetails',
        targetip => $mark->{'ip'},
        targethostname => $mark->{'hostname'},
        targetport => $mark->{'port'},
        targetbanner => $mark->{'banner'} || '',
        starttime => date_disp($mark->{'start_time'}),
        sitename => $XMLRPT_CURR->{'sitename'},
        siteip => $XMLRPT_CURR->{'siteip'},
        hostheader => $XMLRPT_CURR->{'hostheader'},
        errors => $XMLRPT_CURR->{'errors'},
        checks => $XMLRPT_CURR->{'checks'}
    );

    # Write SSL info if available
    if ($XMLRPT_CURR->{'ssl_info'}) {
        $XML_WRITER->emptyTag('ssl',
            ciphers => $XMLRPT_CURR->{'ssl_info'}->{'ciphers'},
            issuers => $XMLRPT_CURR->{'ssl_info'}->{'issuers'},
            info => $XMLRPT_CURR->{'ssl_info'}->{'info'},
            cn => $XMLRPT_CURR->{'ssl_info'}->{'cn'},
            altnames => $XMLRPT_CURR->{'ssl_info'}->{'altnames'}
        );
    }

    nprint("- XML host entry started for $mark->{'hostname'}", "v");
}

###############################################################################
# end host entry
sub xml2_host_end {
    my ($handle, $mark) = @_;

    # Update host data with end time and elapsed time
    $XMLRPT_CURR->{'endtime'} = date_disp($mark->{'end_time'});
    $XMLRPT_CURR->{'elapsed'} = $mark->{'end_time'} - $mark->{'start_time'};
    $XMLRPT_CURR->{'itemsfound'} = $mark->{'total_vulns'} || 0;

    # Write statistics
    $XML_WRITER->emptyTag('statistics',
        elapsed => $XMLRPT_CURR->{'elapsed'},
        itemsfound => $XMLRPT_CURR->{'itemsfound'},
        itemstested => $XMLRPT_CURR->{'checks'},
        endtime => $XMLRPT_CURR->{'endtime'}
    );

    # Close scandetails and niktoscan tags
    $XML_WRITER->endTag('scandetails');
    $XML_WRITER->endTag('niktoscan');

    nprint("- XML host entry completed for $mark->{'hostname'}", "v");
}

###############################################################################
# add item to current host
sub xml2_item {
    my ($handle, $mark, $item) = @_;

    # Add item to current host's items array
    push(@{$XMLRPT_CURR->{'items'}}, {
        id => $item->{'nikto_id'},
        method => $item->{'method'},
        description => $item->{'message'},
        uri => $item->{'uri'},
        namelink => $item->{'namelink'} || '',
        iplink => $item->{'iplink'} || '',
        references => $item->{'refs'} || ''
    });

    # Write item tag with proper structure
    $XML_WRITER->startTag('item',
        id => $item->{'nikto_id'},
        method => $item->{'method'}
    );

    # Write item content with CDATA for potentially problematic content
    $XML_WRITER->startTag('description');
    $XML_WRITER->cdata($item->{'message'});
    $XML_WRITER->endTag('description');

    $XML_WRITER->startTag('uri');
    $XML_WRITER->cdata($item->{'uri'});
    $XML_WRITER->endTag('uri');

    $XML_WRITER->startTag('namelink');
    $XML_WRITER->cdata($item->{'namelink'} || '');
    $XML_WRITER->endTag('namelink');

    $XML_WRITER->startTag('iplink');
    $XML_WRITER->cdata($item->{'iplink'} || '');
    $XML_WRITER->endTag('iplink');

    $XML_WRITER->startTag('references');
    $XML_WRITER->cdata($item->{'refs'} || '');
    $XML_WRITER->endTag('references');

    $XML_WRITER->endTag('item');
}

###############################################################################
# close output file
sub xml2_close {
    my ($handle) = @_;

    # Close root element
    $XML_WRITER->endTag('niktoscans');
    
    # End the XML writer
    $XML_WRITER->end();

    # Close file handle
    close($XML_HANDLE) if $XML_HANDLE;

    # Validate XML if possible
    xml2_validate_output($handle);

    nprint("- XML report completed with proper structure", "v");
}

###############################################################################
# Validate XML output
sub xml2_validate_output {
    my ($filename) = @_;
    
    # Only validate if XML::LibXML is available
    eval {
        require XML::LibXML;
        
        my $parser = XML::LibXML->new();
        my $doc = $parser->parse_file($filename);
        
        # Validate against DTD if available
        if (defined $CONFIGFILE{'NIKTODTD'} && $CONFIGFILE{'NIKTODTD'} ne '') {
            $doc->validate();
            nprint("- XML output validated against DTD successfully", "v");
        } else {
            nprint("- XML output is well-formed", "v");
        }
    };
    if ($@) {
        nprint("+ WARNING: XML validation failed: $@", "e");
    }
}

###############################################################################
# Helper function to safely encode XML content
sub xml2_safe_encode {
    my ($content) = @_;
    return '' unless defined $content;
    
    # XML::Writer handles most escaping, but we can add extra safety
    $content =~ s/[\x00-\x08\x0B\x0C\x0E-\x1F]//g;  # Remove control chars except tab, LF, CR
    return $content;
}

sub nikto_reports { }    # so core doesn't freak

1; 